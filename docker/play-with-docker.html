<!DOCTYPE html>
<html>
<head>
   <title></title>
	<link rel="shortcut icon" href="/favicon.ico">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
   <link href="../android/docs.css" rel="stylesheet" type="text/css" />
   <link href="docs.css" rel="stylesheet" type="text/css" />
   <link href="../git/docs.css" rel="stylesheet" type="text/css" />
   <link href="../letsencrypt/docs.css" rel="stylesheet" type="text/css" />
   <link href="../play/docs.css" rel="stylesheet" type="text/css" />
   <link href="docs2.css" rel="stylesheet" type="text/css" />
   <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-281408-1', 'auto');
     ga('send', 'pageview');

   </script>
</head>
<body>
   <div id="ocean">
      <div id="ship">
         <div id="toprighter">
            <a href="http://creativecommons.org/licenses/by-sa/2.5/"><img
               src="/images/cc-by-sa-small.png" alt="cc by-sa"
               title="Creative Commons Attributions-ShareAlike"
               border="0" align="right" /></a>
            <a href="http://flurdy.com"><img src="/images/flurdy_warped_dual_small.png" border="0" align="right" alt="flurdy" title="" class="flurdySmall"/></a>
         </div>
         <header>
            <h1>
               Play with Docker
            </h1>
            <h4>
               Building Docker images of applications
               that uses the Play &nbsp;Framework.
            </h4>
         </header>
         <nav id="lookout">
            <ul class="horizontal">
               <li><a href="http://flurdy.com">flurdy</a></li>
               <li><a href="http://twitter.com/flurdy">@flurdy</a></li>
               <li><a href="http://blog.flurdy.com">blog</a></li>
               <li><a href="http://shirts.flurdy.com">shirts</a></li>
               <li><a href="http://www.eray.uk">hire</a></li>
               <li><a href="/docs/">more docs</a></li>
            </ul>
         </nav>
         <div id="jib">
            Started: December 2016.
            Last updated: 13th Dec 2016.
         </div>
         <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
         <!-- flurdy.com play with docker -->
         <ins class="adsbygoogle"
              style="display:inline-block;width:728px;height:90px"
              data-ad-client="ca-pub-7805345644641760"
              data-ad-slot="8190445284"></ins>
         <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
         </script>

         <div id="starboard">
            <nav>
                 <h5>Contents</h5>
                 <ul>
                    <li>
                       <a href="#problem">The&nbsp;problem</a>
                       <ul>
                          <li><a href="#problem-downloading">Downloading the internet</a></li>
                          <li><a href="#problem-docker">Inside a Docker container</a></li>
                       </ul>
                    </li>
                    <li>
                       <a href="#full">Full&nbsp;Play Docker&nbsp;build</a>
                       <!--
                       <ul>
                          <li><a href="#full-base">Base image (FROM)</a></li>
                          <li><a href="#full-activator">Download and install Activator</a></li>
                          <li><a href="#full-folders">Application folders</a></li>
                          <li><a href="#full-executable">Executable</a></li>
                          <li><a href="#full-port">Port</a></li>
                       </ul>
                       -->
                    </li>
                    <li>
                       <a href="#base-image">Better&nbsp;base&nbsp;image</a>
                       <ul>
                          <li><a href="#base-java">Java base image</a></li>
                          <li><a href="#base-activator">Activator base image</a></li>
                       </ul>
                    </li>
                    <li>
                       <a href="#caching">Caching</a>
                       <ul>
                          <li><a href="#caching-folders">Mount Ivy &amp; Maven</a></li>
                          <li><a href="#caching-repository">Local repository</a></li>
                       </ul>
                    </li>
                    <li>
                       <a href="#pre-populated">Pre-populated Ivy</a>
                       <ul>
                          <li><a href="#pre-play-base">Play base image</a></li>
                          <li><a href="#pre-app-base">Application base image</a></li>
                       </ul>
                    </li>
                    <li>
                       <a href="#two-step">Two&nbsp;step build</a>
                       <ul>
                          <li><a href="#two-step-manual">Manual binary build</a></li>
                          <li><a href="#two-step-integration">Integration&nbsp;server binary&nbsp;build</a></li>
                       </ul>
                    </li>
                    <li>
                       <a href="#environment">Environment configuration</a>
                       <ul>
                          <li><a href="#environment-runtime">Run&nbsp;time configuration</a></li>
                          <li><a href="#environment-images">Image per environment</a></li>
                       </ul>
                    </li>
                    <li><a href="#alternatives">Alternatives</a></li>
                    <li><a href="#references">References</a></li>
                    <li><a href="#contact">Feedback</a></li>
                 </ul>
             </nav>
         </div>
         <div id="cargo">

            <div class="paragraph">

               <p>
                  Advice on how to build
                  <a href="https://www.playframework.com">Play Framework</a>
                  <a href="https://www.docker.com">Docker</a> images.
                  What are the potential issues,
                  and suggested solutions and alternatives.
                  Is also relevant for any other <a href="https://www.scala-lang.org">Scala</a> based application images.
               </p>

               <div class="paragraph">
                  <h4>Play Framework</h4>
                  <p>
                     What is the <a href="https://www.playframework.com">Play Framework</a>?
                     Play is an application framework
                     popular for web applications and
                     web services.
                  </p>
                  <p>
                     It offers non blocking requests,
                     and many other innovative features
                     and sub projects.
                     The application code can be in either
                     <a href="https://www.oracle.com/java/index.html">Java</a> or
                     <em>Scala</em>.
                     And it runs on the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a>.
                  </p>
               </div>

               <div class="paragraph">
                  <h4>Docker</h4>
                  <p>
                     What is <a href="https://www.docker.com">Docker</a>?
                     Docker is a virtualisation technology
                     that create a simple abstraction layer
                     to run containers for single use applications.
                  </p>
                  <p>
                     An application is <em>dockerised</em>
                     by a <a href="https://docs.docker.com/engine/reference/builder/">DockerFile</a>.
                     The <em>DockerFile</em> describes what base image the application is built upon.
                     E.g. a plain OS image such as <a href="https://hub.docker.com/_/ubuntu/">Ubuntu Linux</a>,
                     or an image built on top of that with certain framework(s) already installed, e.g.
                     <a href="https://hub.docker.com/_/node/">Node.js</a>, <a href="https://hub.docker.com/_/django/">Django</a>, etc.
                     The <em>DockerFile</em> then describes further steps to build and run the application.
                     Such as what further tools and frameworks to install,
                     environment variables, what executable to run and ports to expose.
                  </p>
               </p>
            </div>
         </div>

            <a name="problem"></a>
            <a name="problem-downloading"></a>
            <div class="paragraph">

               <h3>The problem</h3>

               <div class="paragraph">
                  <h4>Downloading the internet</h4>
                  <p>
                     Play depends on a set of <a href="http://ant.apache.org/ivy/">Ivy</a> and <a href="https://maven.apache.org/">Maven</a> dependencies.
                     And the application most likely depends on a further set of dependencies.
                     And these dependencies have further transient dependencies.
                  </p>
                  <p>
                     These dependencies will all have to downloaded from central repositories.
                     And you might need beyond 100 dependencies of a few megabytes each,
                     so the total is often several hundred magabytes.
                     On a fresh install where you need to download everything
                     this is what is populary is called <em>downloading the internet</em>.
                  </p>
                  <img id="downloading-meme" src="downloading.jpg" alt="" />
                  <p>
                     Downloading this on a poor/slow internet connection is when you discover new profanities.
                  </p>
                  <p>
                     Obviously that is inefficient and on a local computer
                     these dependencies are cached within a <em>~/.m2</em> or <em>~/.ivy2</em> folder.
                     That way you only download new dependencies which is rare.
                  </p>
                  <p>
                     And at a organisational level you even prevent fresh installs from needing to
                     download across the internet by using a <a href="https://maven.apache.org/guides/introduction/introduction-to-repositories.html">local repository cache server</a>, such as <a href="https://www.jfrog.com/open-source/#os-arti">Artifactory</a>, <a href="http://www.sonatype.org/nexus/">Nexus</a>, etc.
                  </p>
               </div>

               <a name="problem-docker"></a>
               <div class="paragraph">

                  <h4>
                     Downloading the internet inside a Docker container
                  </h4>
                  <p>
                     But when building a Play application with Docker,
                     you do not have a pre populated <em>~/ivy2</em> folder.
                     And if this is a public project you would not hard code in a dependency
                     on a local maven repository server either.
                  </p>
                  <p>
                     So on each build it will <em>download the internet</em>. Every time.
                  </p>
                  <p>
                     Which is like frequently watching paint dry.
                     And very frustrating when neededing to test a new version if relying it on
                     for <a href="https://en.wikipedia.org/wiki/Continuous_integration">Continuous Integeration</a>.
                     It is also costly on network bandwith.
                  </p>
                  <p>
                     This tutorial will discuss the possible solutions and work arounds to this problem.
                  </p>
               </div>
            </div>

            <a name="full"></a>
            <div class="paragraph">

               <h3>Full Play Docker build</h3>

               <p>
                  Ignoring the problem above here is a full <em>Dockerfile</em>,
                  that will have <em>Java</em> installed, download <em>Activator</em>, and build the application.
               </p>
               <code class="file wide">
                  FROM alpine:3.4<br/>
                  <br/>
                  MAINTAINER <em>YOURNAME</em> &lt;<em>EMAIL/HANDLE</em>&gt;<br/>
                  <br/>
                  RUN apk update &amp;&amp; apk add bash wget unzip openjdk8<br/>
                  <br/>
                  ENV PATH $PATH:/usr/lib/jvm/java-1.8-openjdk/jre/bin:/usr/lib/jvm/java-1.8-openjdk/bin<br/>
                  ENV ACTIVATOR_VERSION <em>1.3.12</em><br/>
                  <br/>
                  RUN mkdir -p /opt/build /etc/app<br/>
                  <br/>
                  WORKDIR /opt<br/>
                  <br/>
                  RUN wget -q --show-progress \<br/>
                     &nbsp;&nbsp;<span class="tiny-code">http://downloads.typesafe.com/typesafe-activator/$ACTIVATOR_VERSION/typesafe-activator-$ACTIVATOR_VERSION-minimal.zip</span> &amp;&amp; \<br/>
                     &nbsp;&nbsp;unzip -qq typesafe-activator-$ACTIVATOR_VERSION-minimal.zip &amp;&amp; \<br/>
                     &nbsp;&nbsp;mv activator-$ACTIVATOR_VERSION-minimal activator &amp;&amp; \<br/>
                     &nbsp;&nbsp;ln -s /opt/activator/bin/activator /usr/local/bin/activator &amp;&amp; \<br/>
                     &nbsp;&nbsp;rm -f typesafe-activator-$ACTIVATOR_VERSION-minimal.zip<br/>
                  <br/>
                  COPY conf /etc/app/<br/>
                  <br/>
                  ADD . /opt/build/<br/>
                  <br/>
                  WORKDIR /opt/build<br/>
                  <br/>
                  RUN /opt/activator/bin/activator clean stage &amp;&amp; \<br/>
                     &nbsp;&nbsp;rm -f target/universal/stage/bin/*.bat &amp;&amp; \<br/>
                     &nbsp;&nbsp;mv target/universal/stage/bin/* target/universal/stage/bin/app &amp;&amp; \<br/>
                     &nbsp;&nbsp;mv target/universal /opt/app &amp;&amp; \<br/>
                     &nbsp;&nbsp;ln -s /opt/app/stage/logs /var/log/app &amp;&amp; \<br/>
                     &nbsp;&nbsp;rm -rf /opt/build /opt/activator $HOME/.ivy2<br/>
                  <br/>
                  WORKDIR /opt/app<br/>
                  <br/>
                  ENTRYPOINT ["/opt/app/stage/bin/app"]<br/>
                  <br/>
                  EXPOSE 9000
               </code>

               <a name="full-base"></a>
               <div class="paragraph">
                  <h4>Base image (FROM)</h4>
                  <p>
                     This bases the image on <em>alpine:3.4</em> with <a href="https://alpinelinux.org/">Alpine Linux</a> as the OS.
                     Alpine is a very barebones OS with a small footprint and has become a very popular as a base Docker image.
                  </p>
               </div>

               <a name="full-activator"></a>
               <div class="paragraph">
                  <h4>Download and install Activator</h4>
                  <p>
                     The <em>RUN wget ...</em> part downloads <em>Activator</em> and install it.
                     It removes the zip file to keep the footprint low.
                     It also does this all in one <a href="https://docs.docker.com/engine/reference/run/">RUN</a> command to keep the changes within one <a href="https://www.ctl.io/developers/blog/post/caching-docker-images/">Docker layer</a>
                  </p>
                  <p>
                     You could include a pre downloaded zip file in your project folder.
                     But for a public utility Dockerfile to avoid the suspicion of tampering of the zip file,
                     I recommend the image downloads it from the source.
                  </p>
               </div>

               <a name="full-folders"></a>
               <div class="paragraph">

                  <h4>Application folders</h4>
                  <ul>
                     <li><em>/opt/build</em>: The application is built here and then later removed</li>
                     <li><em>/opt/app</em>: The compiled application is located here</li>
                     <li><em>/etc/app</em>: The configuration is copied here for ease of overriding</li>
                     <li><em>/var/log/app</em>: The application's logs</li>
                  </ul>
               </div>

               <a name="full-executable"></a>
               <div class="paragraph">

                  <h4>Executable</h4>
                  <p>
                     If you build Play with the <em>stage</em> command then
                     Play framework creates executables in its <em>target/universal/stage/bin</em> folder.
                     This Dockerfile renames the non Windows script and moves it to <em>/opt/app/stage/bin/app</em>.
                  </p>
                  <p>
                     Alternatively you can use the <em>dist</em> command, or
                     <a href="https://github.com/sbt/sbt-assembly">SBT Assembly plugin</a> to create a binary to execute.
                  </p>
                  <p>
                     You can extend the <a href="https://docs.docker.com/engine/reference/builder/#/entrypoint">Entrypoint</a>
                     to include more configurations.
                     E.g. an alternative conf file:
                  </p>
                  <code class="wide">ENTRYPOINT ["/opt/app/stage/bin/app", "-Dconfig.file=/etc/app/alternative.conf"]</code>
               </div>

               <a name="full-port"></a>
               <div class="paragraph">

                  <h4>Port</h4>
                  <p>
                     The application is available on port <em>9000</em>.
                     You can map that port to something else wherever you host your container.
                     Port <em>9999</em> can also be exposed as a debug port.
                  </p>
               </div>
            </div>

            <a name="base-image"></a>
            <a name="base-java"></a>
            <div class="paragraph">

               <h3>Better base image</h3>

               <p>
                  If you built the above image you would have noticed as expected it took forever, if not timed out.
                  You would have to download all the Docker layers of the <em>Alpine</em> base layer first
                  (though this will now be cached by the local Docker client).
                  Then download <em>Java</em>,
                  then download <em>Activator</em>,
                  then the core <a href="http://www.scala-sbt.org/">SBT</a> jars,
                  then the applications dependencies jars
                  and finally compile it all.
               </p>
               <p>
                  It would save you a lot of time to base your image off a more defined base image.
                  Alternative base images are:
               </p>
               <ul>
                  <li>
                     OS images:
                     <ul>
                        <li><em>ubuntu:16.04</em> from <a href="https://hub.docker.com/_/ubuntu/">Docker Ubuntu</a></li>
                        <li><em>debian:jessie-slim</em> from <a href="https://hub.docker.com/_/debian/">Docker Debian</a></li>
                        <li><em>phusion/baseimage:0.9.19</em> from <a href="http://phusion.github.io/baseimage-docker/">Phusion</a>.</li>
                     </ul>
                  </li>
                  <li>
                     With Java:
                     <ul>
                        <li><em>openjdk:8u111-jdk-alpine</em> with <a href="https://en.wikipedia.org/wiki/OpenJDK">OpenJDK</a> 8 preinstalled</li>
                        <li><em>openjdk:8u111-jdk</em> with <em>Debian Jessie</em> as base OS</li>
                        <li><em>flurdy/oracle-java8:8u66</em> from <a href="https://hub.docker.com/r/flurdy/oracle-java8/">JDK 8 by Oracle</a></li>
                        <!-- <li><em>flurdy/oracle-java8:8u111</em> from <a href="https://hub.docker.com/r/flurdy/oracle-java8/">JDK 8 by Oracle</a></li> -->
                     </ul>
                  </li>
                  <li>
                     With Activator:
                     <ul>
                        <li><em>flurdy/activator:1.3.12-alpine</em> with <a href="https://hub.docker.com/r/flurdy/activator/">Activator pre-downloaded</a></li>
                        <li><em>flurdy/activator-mini:1.3.12-alpine</em> with <a href="https://hub.docker.com/r/flurdy/activator-mini/">Activator minimal pre-downloaded</a></li>
                     </ul>
                  </li>
                  <li>
                     With Play:
                     <ul>
                        <li>
                           <em>flurdy/play-framework:2.5.10-alpine</em> from <a href="https://hub.docker.com/r/flurdy/play-framework/">my Docker Play Framework</a>
                        </li>
                     </ul>
                  </li>
               </ul>

               <div class="paragraph">
                  <h4>Java base image</h4>
                  <p>
                     Instead of the OS only <em>alpine</em> image,
                     you could use the <em>OpenJDK</em> one.
                  </p>
                  <code class="file wide">
                     FROM openjdk:<em>8u111</em>-jdk<em>-alpine</em><br/>
                     <br/>
                     MAINTAINER YOURNAME &lt;EMAIL/HANDLE&gt;<br/>
                     <br/>
                     RUN apk update &amp;&amp; apk add bash wget unzip<br/>
                     <br/>
                     ENV ACTIVATOR_VERSION <em>1.3.12</em><br/>
                     <br/>
                     RUN mkdir -p /opt/build /etc/app<br/>
                     <br/>
                     WORKDIR /opt<br/>
                     <br/>
                     RUN wget -q --show-progress \<br/>
                        &nbsp;&nbsp;<span class="tiny-code">http://downloads.typesafe.com/typesafe-activator/$ACTIVATOR_VERSION/typesafe-activator-$ACTIVATOR_VERSION-minimal.zip</span> &amp;&amp; \<br/>
                        &nbsp;&nbsp;unzip -qq typesafe-activator-$ACTIVATOR_VERSION-minimal.zip &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv activator-$ACTIVATOR_VERSION-minimal activator &amp;&amp; \<br/>
                        &nbsp;&nbsp;ln -s /opt/activator/bin/activator /usr/local/bin/activator &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -f typesafe-activator-$ACTIVATOR_VERSION-minimal.zip<br/>
                     <br/>
                     COPY conf /etc/app/<br/>
                     <br/>
                     ADD . /opt/build/<br/>
                     <br/>
                     WORKDIR /opt/build<br/>
                     <br/>
                     RUN /opt/activator/bin/activator clean stage &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -f target/universal/stage/bin/*.bat &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal/stage/bin/* target/universal/stage/bin/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal /opt/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;ln -s /opt/app/stage/logs /var/log/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -rf /opt/build /opt/activator $HOME/.ivy2<br/>
                     <br/>
                     WORKDIR /opt/app<br/>
                     <br/>
                     ENTRYPOINT ["/opt/app/stage/bin/app"]<br/>
                     <br/>
                     EXPOSE 9000
                  </code>
               </div>

               <a name="base-activator"></a>
               <div class="paragraph">
                  <h4>Activator base image</h4>
                  <p>
                     If you trust <a href="https://github.com/flurdy/Dockerfiles/blob/master/activator/mini/alpine/Dockerfile">my Activator image</a> you could save a further step by using it as a base image:
                  </p>
                  <code class="file wide">
                     FROM flurdy/activator-mini:<em>1.3.12-alpine</em><br/>
                     <br/>
                     MAINTAINER YOURNAME &lt;EMAIL/HANDLE&gt;<br/>
                     <br/>
                     RUN mkdir -p /opt/build /etc/app<br/>
                     <br/>
                     COPY conf /etc/app/<br/>
                     <br/>
                     ADD . /opt/build/<br/>
                     <br/>
                     WORKDIR /opt/build<br/>
                     <br/>
                     RUN /opt/activator/bin/activator clean stage &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -f target/universal/stage/bin/*.bat &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal/stage/bin/* target/universal/stage/bin/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal /opt/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;ln -s /opt/app/stage/logs /var/log/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -rf /opt/build /opt/activator $HOME/.ivy2<br/>
                     <br/>
                     WORKDIR /opt/app<br/>
                     <br/>
                     ENTRYPOINT ["/opt/app/stage/bin/app"]<br/>
                     <br/>
                     EXPOSE 9000
                  </code>
                  <p>
                     We use the <em>minimal</em> version of Activator.
                     The <em>dist</em> version would mean a lot of unneccessary bloat in our Docker layer.
                  </p>
               </div>
            </div>

            <a name="caching"></a>
            <a name="caching-folders"></a>
            <div class="paragraph">

               <h3>Caching</h3>

               <p>
                  With the <em>Activator</em> base image you have removed the need to download Java and Activator.
                  But still will need to <em>download the internet</em> for all the <em>Ivy/Maven</em> dependencies.
               </p>
               <div class="paragraph">
                  <h4>Mount Ivy &amp; Maven folders</h4>
                  <p>
                     <em>SBT</em> will try to download all dependencies that it can not find
                     in the local <em>~/ivy2</em> or <em>~/.m2</em> folders.
                     If the binaries needed are present somehow in these folders you avoid <em>downloading the internet</em>.
                  </p>
                  <p>
                     I have <a href="http://blog.flurdy.com/2014/11/dont-download-internet-share-maven-ivy-docker.html">with mixed success accomplished this</a>
                     by mounting my local <em>~/ivy2</em> or <em>~/.m2</em> folders into Docker.
                  </p>
                  <p>
                     It is not as simple as using the <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">Volume</a> parameter for Docker containers
                     as it is the special Docker builder container that needs the folders present.
                     Doing this varies on a <em>Linux</em> box,
                     inside <a href="https://www.vagrantup.com/">Vagrant</a>
                     and on a <em>macOS/OSX</em> machine with either <a href="http://boot2docker.io/">boot2docker</a>
                     or <a href="https://github.com/mist64/xhyve/">xhyve</a>/moby.
                  </p>
                  <p>
                     The problem is that you would have to do this on all clients that may build this image.
                     So I do not recommend it.
                  </p>
                  <p>
                     I think some <a href="https://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration</a> providers
                     such as <a href="https://circleci.com/">CircleCI</a> does this caching somehow in a better way.
                  </p>
               </div>
               <a name="caching-repository"></a>
               <div class="paragraph">
                  <h4>Local repository</h4>
                  <p>
                     A better way is to tell SBT to first look in other locations before
                     going across the internet to find dependencies.
                     Such as a local maven repository server.
                  </p>
                  <p>
                     You can hard code in your projects <em>build.sbt</em> file the location of proxy repository resolvers:
                  </p>
                  <code class="wide">resolvers += "My Special Repository" at "http://repository.example.com/path/"</code>
                  <p>
                     But that is not very flexible so the prefered option is a special <em>~/.sbt/repositories</em> file.
                     The contents of this file depends on your set up.
                     See <a href="http://www.scala-sbt.org/0.13/docs/Proxy-Repositories.html">the reference for examples</a>.
                     Below we have enabled local <em>Ivy</em> folders and proxy server called "<em>special-repository</em>",
                     and commented out some other options.
                     (Apologies about the small font, but the Ivy patterns are really stupidly long).
                  </p>
                  <code class="file wide">
                     [repositories]<br/>
                     # activator-local: <span class="very-tiny-code">file://${activator.local.repository-${activator.home-${user.home}/.activator}/repository}, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]</span><br/>
                     local<br/>
                     # maven-local<br/>
                     <em>special-repository: http://repository.example.com/path/</em><br/>
                     # scala-tools-releases<br/>
                     # typesafe-releases: http://typesafe.artifactoryonline.com/typesafe/releases<br/>
                     # typesafe-sbt-releases: <span class="very-tiny-code">http://typesafe.artifactoryonline.com/typesafe/ivy-releases, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]</span><br/>
                     # typesafe-ivy-releases: <span class="very-tiny-code">http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly</span><br/>
                     # maven-central<br/>
                     # sonatype-snapshots: https://oss.sonatype.org/content/repositories/snapshots
                  </code>
                  <p>
                     Create such a file in your projects <em>conf</em> folder. Then your Dockerfile may be altered like this:
                  </p>
                  <code class="file wide">
                     FROM flurdy/activator-mini:1.3.12-alpine<br/>
                     <br/>
                     MAINTAINER YOURNAME &lt;EMAIL/HANDLE&gt;<br/>
                     <br/>
                     RUN mkdir -p /opt/build /etc/app <em>$HOME/.sbt</em><br/>
                     <br/>
                     COPY conf /etc/app/<br/>
                     <br/>
                     <em>COPY conf/repositories /root/.sbt/</em><br/>
                     <br/>
                     ADD . /opt/build/<br/>
                     <br/>
                     WORKDIR /opt/build<br/>
                     <br/>
                     RUN /opt/activator/bin/activator clean stage &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -f target/universal/stage/bin/*.bat &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal/stage/bin/* target/universal/stage/bin/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal /opt/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;ln -s /opt/app/stage/logs /var/log/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -rf /opt/build /opt/activator $HOME/.ivy2<br/>
                     <br/>
                     WORKDIR /opt/app<br/>
                     <br/>
                     ENTRYPOINT ["/opt/app/stage/bin/app"]<br/>
                     <br/>
                     EXPOSE 9000
                  </code>
                  <p>
                     Make sure the "<em>COPY conf/repositories /root/.sbt/</em>" line is before any Activator/SBT <em>RUN</em> commands.
                  </p>
               </div>
            </div>

            <a name="pre-populated"></a>
            <a name="pre-play-base"></a>
            <div class="paragraph">

               <h3>Pre-populated Ivy</h3>
               <p>
                  An better caching solution is to make sure the Docker builder <em>Ivy</em> folder
                  is populated already from a Play build.
                  That way the dependencies will already be cached locally for the real application build.
               </p>

               <div class="paragraph">
                  <h4>Play base image</h4>
                  <p>
                     If you base your application on my <a href="https://hub.docker.com/r/flurdy/play-framework/">Play Framework</a> image,
                     the dependencies for a plain Play application will be present.
                     Which can be 80-100% of the dependencies you need.
                     Your Dockerfile might look like:
                  </p>
                  <code class="file wide">
                     FROM <em>flurdy/play-framework:2.5.10-alpine</em><br/>
                     <br/>
                     MAINTAINER YOURNAME &lt;EMAIL/HANDLE&gt;<br/>
                     <br/>
                     RUN mkdir -p /opt/build /etc/app<br/>
                     <br/>
                     COPY conf /etc/app/<br/>
                     <br/>
                     ADD . /opt/build/<br/>
                     <br/>
                     WORKDIR /opt/build<br/>
                     <br/>
                     RUN /opt/activator/bin/activator clean stage &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -f target/universal/stage/bin/*.bat &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal/stage/bin/* target/universal/stage/bin/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal /opt/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;ln -s /opt/app/stage/logs /var/log/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -rf /opt/build /opt/activator $HOME/.ivy2<br/>
                     <br/>
                     WORKDIR /opt/app<br/>
                     <br/>
                     ENTRYPOINT ["/opt/app/stage/bin/app"]<br/>
                     <br/>
                     EXPOSE 9000
                  </code>
                  <p>
                     If you don't want to use the image above you can create your own Play base image if you include the steps.
                  </p>
                  <code class="file wide">
                     RUN /opt/activator/bin/activator new playframework-base play-scala &amp;&amp; \<br/>
                        &nbsp;&nbsp;cd playframework-base &amp;&amp; \<br/>
                        &nbsp;&nbsp;/opt/activator/bin/activator stage &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -rf /opt/build<br/>
                  </code>
                  <p>
                     Which creates a plain <em>play-scala</em> application, builds it,
                     downloads all dependencies for Play into <em>~/.ivy2</em>,
                     then deletes the application.
                  </p>
               </div>

               <a name="pre-app-base"></a>
               <div class="paragraph">
                  <h4>Application base image</h4>
                  <p>
                     If your application includes a lot of further dependencies,
                     you might want to split the Dockerfile into a "application base"
                     and a "application-main" image.
                     That way the <em>base</em> is only built when framework or dependencies change,
                     whilst the frequent code changes are only causing the <em>main</em> image to be built.
                     Which should be a lot quicker.
                  </p>
                  <p>
                     Your <em>base</em> Dockerfile which might be located in sub folder of the project.
                     It needs a <em>build.sbt</em> file which matches the projects, at least for the dependencies.
                     The <em>base</em> Dockerfile might look something like this:
                  </p>
                  <code class="file wide">
                     FROM flurdy/play-framework:2.5.10-alpine<br/>
                     <br/>
                     MAINTAINER YOURNAME &lt;EMAIL/HANDLE&gt;<br/>
                     <br/>
                     RUN mkdir -p /opt/build<br/>
                     <br/>
                     ADD . /opt/build/<br/>
                     <br/>
                     WORKDIR /opt/build<br/>
                     <br/>
                     RUN /opt/activator/bin/activator new application-base play-scala &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv -f build.sbt application-base/build.sbt &amp;&amp; \<br/>
                        &nbsp;&nbsp;cd application-base &amp;&amp; \<br/>
                        &nbsp;&nbsp;/opt/activator/bin/activator clean stage &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -rf /opt/build<br/>
                  </code>
                  <p>
                     You may build and tag this as e.g.: <em>yourorg/my-application-base</em>.
                     If many applications use the same dependencies this base image could be shared across these.
                     The <em>main</em> Dockerfile might look something like:
                  </p>
                  <code class="file wide">
                     FROM <em>yourorg/my-application-base:latest</em><br/>
                     <br/>
                     MAINTAINER YOURNAME &lt;EMAIL/HANDLE&gt;<br/>
                     <br/>
                     RUN mkdir -p /etc/app /opt/app<br/>
                     <br/>
                     COPY conf /etc/app/<br/>
                     <br/>
                     ADD . /opt/build/<br/>
                     <br/>
                     WORKDIR /opt/build<br/>
                     <br/>
                     RUN /opt/activator/bin/activator clean stage &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -f target/universal/stage/bin/*.bat &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal/stage/bin/* target/universal/stage/bin/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv target/universal /opt/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;ln -s /opt/app/stage/logs /var/log/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;rm -rf /opt/build /opt/activator $HOME/.ivy2<br/>
                     <br/>
                     WORKDIR /opt/app<br/>
                     <br/>
                     ENTRYPOINT ["/opt/app/stage/bin/app"]<br/>
                     <br/>
                     EXPOSE 9000
                  </code>
                  <p>
                     This should now no longer download anything.
                     As long as no dependencies are <em>snapshots</em>
                     or different versions from the base image.
                     It should only compile the application binary.
                  </p>
               </div>

            </div>


            <a name="two-step"></a>
            <a name="two-step-manual"></a>
            <div class="paragraph">

               <h3>Two step build</h3>
               <p>
                  Another way to avoid <em>downloading the internet</em> on each Docker build,
                  is to build the JAR binary outside of Docker.
               </p>

               <div class="paragraph">

                  <h4>Manual binary build</h4>
                  <p>
                     You can build the JAR manually with e.g.:
                  </p>
                  <code>sbt stage</code>
                  <p>
                     Then a Dockerfile like this:
                  </p>
                  <code class="file wide">
                     FROM openjdk:8u111-jdk-alpine<br/>
                     <br/>
                     MAINTAINER YOURNAME &lt;EMAIL/HANDLE&gt;<br/>
                     <br/>
                     RUN apk update &amp;&amp; apk add bash<br/>
                     <br/>
                     RUN mkdir -p /etc/app /opt/app<br/>
                     <br/>
                     WORKDIR /opt/app<br/>
                     <br/>
                     COPY conf /etc/app/<br/>
                     <br/>
                     ADD target/universal /opt/app/<br/>
                     <br/>
                     RUN rm -f stage/bin/*.bat &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv stage/bin/* stage/bin/app &amp;&amp; \<br/>
                        &nbsp;&nbsp;ln -s /opt/app/stage/logs /var/log/app<br/>
                     <br/>
                     ENTRYPOINT ["/opt/app/stage/bin/app"]<br/>
                     <br/>
                     EXPOSE 9000
                  </code>
                  <p>
                     This is a much simpler Dockerfile.
                     But is also much more fragile build as it depends on people
                     and integration servers
                     having pre-built the binary.
                  </p>
               </div>

               <a name="two-step-integration"></a>
               <div class="paragraph">
                  <h4>Integration server binary build</h4>
                  <p>
                     Most organisations will already be practicing the <a href="http://blog.arungupta.me/build-binaries-only-once-continuous-deployment/">one-binary</a>
                     principle of building the JAR with continuous delivery processes.
                     The project binary is built on a continuous integration server and
                     uploaded to a Maven artifact repository.
                     To include that as part of the Docker build the Dockerfile might look like this:
                  </p>
                  <code class="file wide">
                     FROM openjdk:8u111-jdk-alpine<br/>
                     <br/>
                     MAINTAINER YOURNAME &lt;EMAIL/HANDLE&gt;<br/>
                     <br/>
                     ENV ARTREPOSITORY <em>http://example.com/artifactory/libs-release-local</em><br/>
                     ENV ARTNAME    <em>myapplication</em><br/>
                     ENV ARTPATH    <em>com/example/$ARTNAME</em><br/>
                     ENV ARTVERSION <em>1.0-SNAPSHOT</em><br/>
                     ENV ARTURL     <em>$ARTREPOSITORY/$ARTPATH/$ARTVERSION/$ARTNAME-$ARTVERSION.jar</em><br/>
                     <br/>
                     RUN mkdir -p /etc/app /opt/app<br/>
                     <br/>
                     WORKDIR /opt/app<br/>
                     <br/>
                     COPY conf /etc/app/<br/>
                     <br/>
                     <em>ADD bin /opt/app/</em><br/>
                     <br/>
                     <em>RUN wget -q --show-progress $ARTURL &amp;&amp; \<br/>
                        &nbsp;&nbsp;mv $ARTNAME.jar /opt/app/</em><br/>
                     <br/>
                     ENTRYPOINT ["<em>/opt/app/bin/start.sh</em>"]<br/>
                     <br/>
                     EXPOSE 9000
                  </code>
                  <p>
                     The Dockerfile can be made smarter by querying your artifact repository for the latest
                     version dynamically.
                  </p>
                  <p>
                     The <em>start.sh</em> file needs to call Java with the fat jar as classpath,
                     alternatively with some options and then the start class of the application.
                     (<a href="https://github.com/flurdy/docker-compose-machine-swarm-cloud-example/blob/master/service/src/main/resources/start.sh">An example for a spray app</a>).
                  </p>
                  <p>
                     Though many new projects are rethinking this process and
                     move the <em>one-binary</em> principle
                     from one JAR to one Docker image to avoid a two stage build process for each commit.
                  </p>

               </div>
            </div>

            <a name="environment"></a>
            <div class="paragraph">

               <h3>Environment configuration</h3>

               <p>
                  To specify configurations and secrets for the Docker image you have a few options.
                  You can use the same image but override properties at run time.
                  Or you can bake a different image per environment.
               </p>

               <a name="environment-runtime"></a>
               <div class="paragraph">

                  <h4>Run time configuration</h4>
                  <p>
                     You can override the <a href="https://www.playframework.com/documentation/2.5.x/ProductionConfiguration">configuration file</a> used, per property or both.
                  </p>
                  <p>
                     Since we use <a href="https://docs.docker.com/engine/reference/builder/#/entrypoint">Entrypoint</a> (and not <a href="https://docs.docker.com/engine/reference/builder/#cmd">CMD</a>)
                     the command you run the image with only appends to that command,
                     not replace it, which a <em>CMD</em> would do.
                  </p>
                  <code class="wide">docker run -ti --rm <em>yourorg/my-application:latest</em> -Dconfig.file=/etc/app/<em>docker.conf</em></code>
                  <p>
                     This executes the <em>/opt/app/stage/bin/app</em> but appends <em>-Dconfig.file=/etc/app/docker.conf</em>
                     to it.
                     The configuration file can be part of the application's source code in the <em>conf</em> folder,
                     or it can be mounted as a Docker volume at runtime.
                  </p>
                  <p>
                     If you find all the application's Docker containers override with the same config file,
                     then just modify the Dockerfile's <em>Entrypoint</em>:
                  </p>
                  <code class="file wide">
                     ENTRYPOINT ["/opt/app/stage/bin/app", "-Dconfig.file=/etc/app/docker.conf"]
                  </code>
                  <p>
                     Individual properties can also be overriden. Either via <em>-DTHISPROPERTY=thisvalue</em>
                     or even better as a environment variable:
                  </p>
                  <code class="wide">
                     docker run -ti --rm \<br/>
                     &nbsp;&nbsp;-e <em>MYPROPERTY=thisvalue</em>
                     -e <em>OTHERPROPERTY=thatvalue</em>
                     <em>yourorg/my-application:latest</em>
                  </code>
                  <p>
                     Then inside the <em>conf/application.conf</em>:
                  </p>
                  <code class="file">
                     myproperty=<em>some-default-value</em><br/>
                     myproperty=<em>${MYPROPERTY}</em><br/>
                     otherproperty=<em>some-other-default-value</em><br/>
                     otherproperty=<em>${OTHERPROPERTY}</em>
                  </code>
               </div>

               <a name="environment-images"></a>
               <div class="paragraph">
                  <h4>Image per environment</h4>
                  <p>
                     Some might prefer to bake different Docker images per environment.
                     One way to do that is to use the <a href="https://docs.docker.com/engine/reference/builder/#/arg">ARG</a> command.
                  </p>
                  <code class="file wide">
                     ARG targetenv<br/>
                     <br/>
                     RUN mv /etc/app/${targetenv:-docker}.conf /etc/app/environment.conf<br/>
                     <br/>
                     ENTRYPOINT ["/opt/app/stage/bin/app", "-Dconfig.file=/etc/app/environment.conf"]
                  </code>
                  <p>
                     For each build you need to specify what the <em>ARG</em> value is, e.g. staging, production, etc.
                  </p>
                  <code class="wide">docker build --build-arg <em>targetenv=production</em> -t <em>yourorg/my-application-production</em></code>

               </div>
            </div>

            <a name="alternatives"></a>
            <div class="paragraph">

               <h3>Alternatives</h3>

               <p>
                  Instead of thios document's Play &amp; Docker configurations you might consider:
               </p>
               <ul>
                  <li><a href="https://github.com/sbt/sbt-native-packager">SBT Native Packager</a></li>
                  <li><a href="https://github.com/marcuslonnberg/sbt-docker">SBT-Docker</a></li>
               </ul>
            </div>

            <a name="references"></a>
            <div class="paragraph">

               <h3>References</h3>

               <ul>
                  <li><a href="https://www.playframework.com">Play Framework</a></li>
                  <li><a href="https://www.docker.com/">Docker</a></li>
                  <li><a href="https://alpinelinux.org/">Alpine Linux</a></li>
                  <li><a href="https://www.oracle.com/java/index.html">Java</a></li>
                  <li><a href="https://www.scala-lang.org">Scala</a></li>
                  <li><a href="https://hub.docker.com/_/java/">Docker Java</a></li>
                  <li><a href="https://hub.docker.com/r/flurdy/activator-mini/">Docker Activator by Flurdy</a></li>
                  <li><a href="https://hub.docker.com/r/flurdy/play-framework/">Docker Play by Flurdy</a></li>
               </ul>

               <p>
                  I have previously written some related tutorials
                  based on Play, Scala and/or Docker:
               </p>
               <ul>
                  <li><a href="https://flurdy.com/docs/docker/docker_osx_ubuntu.html">Docker with OSX and Ubuntu</a> (a little outdated)</li>
                  <li><a href="https://flurdy.com/docs/docker/docker_compose_machine_swarm_cloud.html">Docker with Compose, Machine and Swarm</a> (Play 2.4)</li>
                  <li><a href="http://flurdy.com/docs/herokuplay/play1.html">Play! + Heroku</a> (Play 1)</li>
                  <li><a href="http://flurdy.com/docs/herokuplay/play2.html">Play! 2.0 + Scala + Heroku</a> (Play 2)</li>
                  <li><a href="http://flurdy.com/docs/play/pizza-scala-play-docker-cloud.html">Pizza in the cloud</a> (Play 2.5 &amp; Docker Cloud)</li>
                  <li><a href="http://flurdy.com/docs/scalainit/startscala.html">Start and stop a Scala application in production</a></li>
               </ul>
            </div>

            <a name="contact"></a>
            <div class="paragraph">
               <a name="contact"></a>
               <h3>Feedback</h3>
               <p>
                  Please <a href="http://github.com/flurdy/flurdy.com-docs">fork and send a pull request</a> for to correct any typos, or useful additions.
               </p>
               <p>
                  <a href="http://shirts.flurdy.com">Buy a t-shirt</a> if you found this guide useful.
                  <a href="http://www.eray.uk">Hire me</a> for short term advice or long term consultancy.
               </p>
               <p>
                  Otherwise <a href="/contact">contact me</a>.
                  Especially for things factually incorrect.
                  Apologies for procrastinated replies.
               </p>
            </div>

         </div>
         <footer>
            <nav>
               <ul class="horizontal">
                  <li><a href="http://flurdy.com">flurdy</a></li>
                  <li><a href="http://twitter.com/flurdy">@flurdy</a></li>
                  <li><a href="http://blog.flurdy.com">blog</a></li>
                  <li><a href="http://shirts.flurdy.com">shirts</a></li>
                  <li><a href="http://www.eray.uk">hire</a></li>
                  <li><a href="/docs/">more docs</a></li>
               </ul>
            </nav>
         </footer>
      </div>
   </div>
   <link href='//fonts.googleapis.com/css?family=Michroma' rel='stylesheet' type='text/css' />
</body>
</html>
